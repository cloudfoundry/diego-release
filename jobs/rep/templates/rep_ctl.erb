#!/bin/bash -e

run_dir=/var/vcap/sys/run/rep
log_dir=/var/vcap/sys/log/rep
conf_dir=/var/vcap/jobs/rep/config

data_dir=/var/vcap/data/executor
cache_dir=<%= p("diego.executor.cache_path") %>
tmp_dir=$data_dir/tmp

pidfile=$run_dir/rep.pid

source /var/vcap/packages/pid_utils/pid_utils.sh

case $1 in

  start)
    pid_guard $pidfile "rep"

    mkdir -p $run_dir
    chown -R vcap:vcap $run_dir

    mkdir -p $log_dir
    chown -R vcap:vcap $log_dir

    mkdir -p $data_dir
    chown -R vcap:vcap $data_dir

    mkdir -p $tmp_dir
    chown -R vcap:vcap $tmp_dir

    mkdir -p $cache_dir
    chown -R vcap:vcap $cache_dir

    drivers_paths=<%= p("diego.executor.volman.driver_paths") %>
    mkdir -p $drivers_paths
    chown vcap:vcap $drivers_paths

    # Key and Cert are generally ~2048 bytes. Add an extra 2048 for extra space
    # add another 4096 to account for the temp files used to do atomic replacement #141163257
    instance_cert_and_key_size=10240
    instance_ca_size=$(wc -c ${conf_dir}/certs/rep/instance_identity.crt | cut -d' ' -f1)
    max_containers=250
    instance_tmpfs_size=$((($instance_ca_size + $instance_cert_and_key_size) * $max_containers))

    instance_identity_dir=${data_dir}/instance_identity
    if mount | grep -q $instance_identity_dir; then
      umount -f $instance_identity_dir
    fi
    mkdir -p "$instance_identity_dir"
    mount -t tmpfs -o size=$instance_tmpfs_size tmpfs $instance_identity_dir
    chown -R vcap:vcap "$instance_identity_dir"
    chmod 0700 "$instance_identity_dir"

    trusted_certs_dir=${data_dir}/trusted_certs
    rm -rf "$trusted_certs_dir"
    <% if_p("diego.rep.trusted_certs") do |value| %>
      mkdir -p "$trusted_certs_dir"
      chown -R vcap:vcap $trusted_certs_dir

      # Split files on '----END CERTIFICATE-----' and increment our file counter by 1
      pushd $trusted_certs_dir
              awk -v n=1 '
                      split_after == 1 {n++;split_after=0}
                      /-----END CERTIFICATE-----/ {split_after=1}
                      NF {print > "trusted_ca_" n ".crt"}' < $conf_dir/certs/rep/trusted_certs.crt
      popd
    <% end %>

    if running_in_container; then
        echo "Not setting /proc/sys/net/ipv4 parameters, since I'm running inside a linux container"
    else
        # TCP_FIN_TIMEOUT
        # This setting determines the time that must elapse before TCP/IP can release a closed connection and reuse
        # its resources. During this TIME_WAIT state, reopening the connection to the client costs less than establishing
        # a new connection. By reducing the value of this entry, TCP/IP can release closed connections faster, making more
        # resources available for new connections. Addjust this in the presense of many connections sitting in the
        # TIME_WAIT state:

        echo 10 > /proc/sys/net/ipv4/tcp_fin_timeout

        # TCP_TW_REUSE
        # This allows reusing sockets in TIME_WAIT state for new connections when it is safe from protocol viewpoint.
        # Default value is 0 (disabled). It is generally a safer alternative to tcp_tw_recycle

        echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse

        # NF_CONNTRACK_MAX
        # Default value is 65536. We set it to a larger number to avoid running out of connections.
        echo 262144 > /proc/sys/net/netfilter/nf_conntrack_max
    fi

    # Allowed number of open file descriptors
    ulimit -n 100000

    exec chpst -u vcap:vcap /var/vcap/jobs/rep/bin/rep_as_vcap

    ;;

  stop)
    kill_and_wait $pidfile

    ;;

  *)
    echo "Usage: rep_ctl {start|stop}"

    ;;

esac
