// Code generated by counterfeiter. DO NOT EDIT.
package os_fake

import (
	"os"
	"sync"

	"code.cloudfoundry.org/goshims/osshim"
)

type FakeFile struct {
	ChdirStub        func() error
	chdirMutex       sync.RWMutex
	chdirArgsForCall []struct {
	}
	chdirReturns struct {
		result1 error
	}
	chdirReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	FdStub        func() uintptr
	fdMutex       sync.RWMutex
	fdArgsForCall []struct {
	}
	fdReturns struct {
		result1 uintptr
	}
	fdReturnsOnCall map[int]struct {
		result1 uintptr
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ReadStub        func([]byte) (int, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 []byte
	}
	readReturns struct {
		result1 int
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ReadAtStub        func([]byte, int64) (int, error)
	readAtMutex       sync.RWMutex
	readAtArgsForCall []struct {
		arg1 []byte
		arg2 int64
	}
	readAtReturns struct {
		result1 int
		result2 error
	}
	readAtReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SeekStub        func(int64, int) (int64, error)
	seekMutex       sync.RWMutex
	seekArgsForCall []struct {
		arg1 int64
		arg2 int
	}
	seekReturns struct {
		result1 int64
		result2 error
	}
	seekReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	StatStub        func() (os.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
	}
	statReturns struct {
		result1 os.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	WriteStub        func([]byte) (int, error)
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 []byte
	}
	writeReturns struct {
		result1 int
		result2 error
	}
	writeReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	WriteAtStub        func([]byte, int64) (int, error)
	writeAtMutex       sync.RWMutex
	writeAtArgsForCall []struct {
		arg1 []byte
		arg2 int64
	}
	writeAtReturns struct {
		result1 int
		result2 error
	}
	writeAtReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	WriteStringStub        func(string) (int, error)
	writeStringMutex       sync.RWMutex
	writeStringArgsForCall []struct {
		arg1 string
	}
	writeStringReturns struct {
		result1 int
		result2 error
	}
	writeStringReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFile) Chdir() error {
	fake.chdirMutex.Lock()
	ret, specificReturn := fake.chdirReturnsOnCall[len(fake.chdirArgsForCall)]
	fake.chdirArgsForCall = append(fake.chdirArgsForCall, struct {
	}{})
	fake.recordInvocation("Chdir", []interface{}{})
	fake.chdirMutex.Unlock()
	if fake.ChdirStub != nil {
		return fake.ChdirStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.chdirReturns
	return fakeReturns.result1
}

func (fake *FakeFile) ChdirCallCount() int {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	return len(fake.chdirArgsForCall)
}

func (fake *FakeFile) ChdirCalls(stub func() error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = stub
}

func (fake *FakeFile) ChdirReturns(result1 error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = nil
	fake.chdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFile) ChdirReturnsOnCall(i int, result1 error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = nil
	if fake.chdirReturnsOnCall == nil {
		fake.chdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFile) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *FakeFile) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeFile) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeFile) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFile) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFile) Fd() uintptr {
	fake.fdMutex.Lock()
	ret, specificReturn := fake.fdReturnsOnCall[len(fake.fdArgsForCall)]
	fake.fdArgsForCall = append(fake.fdArgsForCall, struct {
	}{})
	fake.recordInvocation("Fd", []interface{}{})
	fake.fdMutex.Unlock()
	if fake.FdStub != nil {
		return fake.FdStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fdReturns
	return fakeReturns.result1
}

func (fake *FakeFile) FdCallCount() int {
	fake.fdMutex.RLock()
	defer fake.fdMutex.RUnlock()
	return len(fake.fdArgsForCall)
}

func (fake *FakeFile) FdCalls(stub func() uintptr) {
	fake.fdMutex.Lock()
	defer fake.fdMutex.Unlock()
	fake.FdStub = stub
}

func (fake *FakeFile) FdReturns(result1 uintptr) {
	fake.fdMutex.Lock()
	defer fake.fdMutex.Unlock()
	fake.FdStub = nil
	fake.fdReturns = struct {
		result1 uintptr
	}{result1}
}

func (fake *FakeFile) FdReturnsOnCall(i int, result1 uintptr) {
	fake.fdMutex.Lock()
	defer fake.fdMutex.Unlock()
	fake.FdStub = nil
	if fake.fdReturnsOnCall == nil {
		fake.fdReturnsOnCall = make(map[int]struct {
			result1 uintptr
		})
	}
	fake.fdReturnsOnCall[i] = struct {
		result1 uintptr
	}{result1}
}

func (fake *FakeFile) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakeFile) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeFile) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeFile) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFile) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFile) Read(arg1 []byte) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("Read", []interface{}{arg1Copy})
	fake.readMutex.Unlock()
	if fake.ReadStub != nil {
		return fake.ReadStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFile) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeFile) ReadCalls(stub func([]byte) (int, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeFile) ReadArgsForCall(i int) []byte {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFile) ReadReturns(result1 int, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) ReadReturnsOnCall(i int, result1 int, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) ReadAt(arg1 []byte, arg2 int64) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.readAtMutex.Lock()
	ret, specificReturn := fake.readAtReturnsOnCall[len(fake.readAtArgsForCall)]
	fake.readAtArgsForCall = append(fake.readAtArgsForCall, struct {
		arg1 []byte
		arg2 int64
	}{arg1Copy, arg2})
	fake.recordInvocation("ReadAt", []interface{}{arg1Copy, arg2})
	fake.readAtMutex.Unlock()
	if fake.ReadAtStub != nil {
		return fake.ReadAtStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readAtReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFile) ReadAtCallCount() int {
	fake.readAtMutex.RLock()
	defer fake.readAtMutex.RUnlock()
	return len(fake.readAtArgsForCall)
}

func (fake *FakeFile) ReadAtCalls(stub func([]byte, int64) (int, error)) {
	fake.readAtMutex.Lock()
	defer fake.readAtMutex.Unlock()
	fake.ReadAtStub = stub
}

func (fake *FakeFile) ReadAtArgsForCall(i int) ([]byte, int64) {
	fake.readAtMutex.RLock()
	defer fake.readAtMutex.RUnlock()
	argsForCall := fake.readAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFile) ReadAtReturns(result1 int, result2 error) {
	fake.readAtMutex.Lock()
	defer fake.readAtMutex.Unlock()
	fake.ReadAtStub = nil
	fake.readAtReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) ReadAtReturnsOnCall(i int, result1 int, result2 error) {
	fake.readAtMutex.Lock()
	defer fake.readAtMutex.Unlock()
	fake.ReadAtStub = nil
	if fake.readAtReturnsOnCall == nil {
		fake.readAtReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.readAtReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) Seek(arg1 int64, arg2 int) (int64, error) {
	fake.seekMutex.Lock()
	ret, specificReturn := fake.seekReturnsOnCall[len(fake.seekArgsForCall)]
	fake.seekArgsForCall = append(fake.seekArgsForCall, struct {
		arg1 int64
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("Seek", []interface{}{arg1, arg2})
	fake.seekMutex.Unlock()
	if fake.SeekStub != nil {
		return fake.SeekStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.seekReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFile) SeekCallCount() int {
	fake.seekMutex.RLock()
	defer fake.seekMutex.RUnlock()
	return len(fake.seekArgsForCall)
}

func (fake *FakeFile) SeekCalls(stub func(int64, int) (int64, error)) {
	fake.seekMutex.Lock()
	defer fake.seekMutex.Unlock()
	fake.SeekStub = stub
}

func (fake *FakeFile) SeekArgsForCall(i int) (int64, int) {
	fake.seekMutex.RLock()
	defer fake.seekMutex.RUnlock()
	argsForCall := fake.seekArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFile) SeekReturns(result1 int64, result2 error) {
	fake.seekMutex.Lock()
	defer fake.seekMutex.Unlock()
	fake.SeekStub = nil
	fake.seekReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) SeekReturnsOnCall(i int, result1 int64, result2 error) {
	fake.seekMutex.Lock()
	defer fake.seekMutex.Unlock()
	fake.SeekStub = nil
	if fake.seekReturnsOnCall == nil {
		fake.seekReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.seekReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) Stat() (os.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
	}{})
	fake.recordInvocation("Stat", []interface{}{})
	fake.statMutex.Unlock()
	if fake.StatStub != nil {
		return fake.StatStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.statReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFile) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeFile) StatCalls(stub func() (os.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeFile) StatReturns(result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) StatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) Write(arg1 []byte) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("Write", []interface{}{arg1Copy})
	fake.writeMutex.Unlock()
	if fake.WriteStub != nil {
		return fake.WriteStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.writeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFile) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeFile) WriteCalls(stub func([]byte) (int, error)) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeFile) WriteArgsForCall(i int) []byte {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFile) WriteReturns(result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) WriteReturnsOnCall(i int, result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) WriteAt(arg1 []byte, arg2 int64) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.writeAtMutex.Lock()
	ret, specificReturn := fake.writeAtReturnsOnCall[len(fake.writeAtArgsForCall)]
	fake.writeAtArgsForCall = append(fake.writeAtArgsForCall, struct {
		arg1 []byte
		arg2 int64
	}{arg1Copy, arg2})
	fake.recordInvocation("WriteAt", []interface{}{arg1Copy, arg2})
	fake.writeAtMutex.Unlock()
	if fake.WriteAtStub != nil {
		return fake.WriteAtStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.writeAtReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFile) WriteAtCallCount() int {
	fake.writeAtMutex.RLock()
	defer fake.writeAtMutex.RUnlock()
	return len(fake.writeAtArgsForCall)
}

func (fake *FakeFile) WriteAtCalls(stub func([]byte, int64) (int, error)) {
	fake.writeAtMutex.Lock()
	defer fake.writeAtMutex.Unlock()
	fake.WriteAtStub = stub
}

func (fake *FakeFile) WriteAtArgsForCall(i int) ([]byte, int64) {
	fake.writeAtMutex.RLock()
	defer fake.writeAtMutex.RUnlock()
	argsForCall := fake.writeAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFile) WriteAtReturns(result1 int, result2 error) {
	fake.writeAtMutex.Lock()
	defer fake.writeAtMutex.Unlock()
	fake.WriteAtStub = nil
	fake.writeAtReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) WriteAtReturnsOnCall(i int, result1 int, result2 error) {
	fake.writeAtMutex.Lock()
	defer fake.writeAtMutex.Unlock()
	fake.WriteAtStub = nil
	if fake.writeAtReturnsOnCall == nil {
		fake.writeAtReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeAtReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) WriteString(arg1 string) (int, error) {
	fake.writeStringMutex.Lock()
	ret, specificReturn := fake.writeStringReturnsOnCall[len(fake.writeStringArgsForCall)]
	fake.writeStringArgsForCall = append(fake.writeStringArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WriteString", []interface{}{arg1})
	fake.writeStringMutex.Unlock()
	if fake.WriteStringStub != nil {
		return fake.WriteStringStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.writeStringReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFile) WriteStringCallCount() int {
	fake.writeStringMutex.RLock()
	defer fake.writeStringMutex.RUnlock()
	return len(fake.writeStringArgsForCall)
}

func (fake *FakeFile) WriteStringCalls(stub func(string) (int, error)) {
	fake.writeStringMutex.Lock()
	defer fake.writeStringMutex.Unlock()
	fake.WriteStringStub = stub
}

func (fake *FakeFile) WriteStringArgsForCall(i int) string {
	fake.writeStringMutex.RLock()
	defer fake.writeStringMutex.RUnlock()
	argsForCall := fake.writeStringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFile) WriteStringReturns(result1 int, result2 error) {
	fake.writeStringMutex.Lock()
	defer fake.writeStringMutex.Unlock()
	fake.WriteStringStub = nil
	fake.writeStringReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) WriteStringReturnsOnCall(i int, result1 int, result2 error) {
	fake.writeStringMutex.Lock()
	defer fake.writeStringMutex.Unlock()
	fake.WriteStringStub = nil
	if fake.writeStringReturnsOnCall == nil {
		fake.writeStringReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeStringReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeFile) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.fdMutex.RLock()
	defer fake.fdMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.readAtMutex.RLock()
	defer fake.readAtMutex.RUnlock()
	fake.seekMutex.RLock()
	defer fake.seekMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	fake.writeAtMutex.RLock()
	defer fake.writeAtMutex.RUnlock()
	fake.writeStringMutex.RLock()
	defer fake.writeStringMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFile) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ osshim.File = new(FakeFile)
