// Code generated by counterfeiter. DO NOT EDIT.
package os_fake

import (
	"os"
	"sync"
	"time"

	"code.cloudfoundry.org/goshims/osshim"
)

type FakeOs struct {
	ChdirStub        func(string) error
	chdirMutex       sync.RWMutex
	chdirArgsForCall []struct {
		arg1 string
	}
	chdirReturns struct {
		result1 error
	}
	chdirReturnsOnCall map[int]struct {
		result1 error
	}
	ChmodStub        func(string, os.FileMode) error
	chmodMutex       sync.RWMutex
	chmodArgsForCall []struct {
		arg1 string
		arg2 os.FileMode
	}
	chmodReturns struct {
		result1 error
	}
	chmodReturnsOnCall map[int]struct {
		result1 error
	}
	ChownStub        func(string, int, int) error
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	chownReturns struct {
		result1 error
	}
	chownReturnsOnCall map[int]struct {
		result1 error
	}
	ChtimesStub        func(string, time.Time, time.Time) error
	chtimesMutex       sync.RWMutex
	chtimesArgsForCall []struct {
		arg1 string
		arg2 time.Time
		arg3 time.Time
	}
	chtimesReturns struct {
		result1 error
	}
	chtimesReturnsOnCall map[int]struct {
		result1 error
	}
	ClearenvStub        func()
	clearenvMutex       sync.RWMutex
	clearenvArgsForCall []struct {
	}
	CreateStub        func(string) (osshim.File, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 string
	}
	createReturns struct {
		result1 osshim.File
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 osshim.File
		result2 error
	}
	EnvironStub        func() []string
	environMutex       sync.RWMutex
	environArgsForCall []struct {
	}
	environReturns struct {
		result1 []string
	}
	environReturnsOnCall map[int]struct {
		result1 []string
	}
	ExitStub        func(int)
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		arg1 int
	}
	ExpandStub        func(string, func(string) string) string
	expandMutex       sync.RWMutex
	expandArgsForCall []struct {
		arg1 string
		arg2 func(string) string
	}
	expandReturns struct {
		result1 string
	}
	expandReturnsOnCall map[int]struct {
		result1 string
	}
	ExpandEnvStub        func(string) string
	expandEnvMutex       sync.RWMutex
	expandEnvArgsForCall []struct {
		arg1 string
	}
	expandEnvReturns struct {
		result1 string
	}
	expandEnvReturnsOnCall map[int]struct {
		result1 string
	}
	FindProcessStub        func(int) (*os.Process, error)
	findProcessMutex       sync.RWMutex
	findProcessArgsForCall []struct {
		arg1 int
	}
	findProcessReturns struct {
		result1 *os.Process
		result2 error
	}
	findProcessReturnsOnCall map[int]struct {
		result1 *os.Process
		result2 error
	}
	GetegidStub        func() int
	getegidMutex       sync.RWMutex
	getegidArgsForCall []struct {
	}
	getegidReturns struct {
		result1 int
	}
	getegidReturnsOnCall map[int]struct {
		result1 int
	}
	GetenvStub        func(string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		arg1 string
	}
	getenvReturns struct {
		result1 string
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
	}
	GeteuidStub        func() int
	geteuidMutex       sync.RWMutex
	geteuidArgsForCall []struct {
	}
	geteuidReturns struct {
		result1 int
	}
	geteuidReturnsOnCall map[int]struct {
		result1 int
	}
	GetgidStub        func() int
	getgidMutex       sync.RWMutex
	getgidArgsForCall []struct {
	}
	getgidReturns struct {
		result1 int
	}
	getgidReturnsOnCall map[int]struct {
		result1 int
	}
	GetgroupsStub        func() ([]int, error)
	getgroupsMutex       sync.RWMutex
	getgroupsArgsForCall []struct {
	}
	getgroupsReturns struct {
		result1 []int
		result2 error
	}
	getgroupsReturnsOnCall map[int]struct {
		result1 []int
		result2 error
	}
	GetpagesizeStub        func() int
	getpagesizeMutex       sync.RWMutex
	getpagesizeArgsForCall []struct {
	}
	getpagesizeReturns struct {
		result1 int
	}
	getpagesizeReturnsOnCall map[int]struct {
		result1 int
	}
	GetpidStub        func() int
	getpidMutex       sync.RWMutex
	getpidArgsForCall []struct {
	}
	getpidReturns struct {
		result1 int
	}
	getpidReturnsOnCall map[int]struct {
		result1 int
	}
	GetppidStub        func() int
	getppidMutex       sync.RWMutex
	getppidArgsForCall []struct {
	}
	getppidReturns struct {
		result1 int
	}
	getppidReturnsOnCall map[int]struct {
		result1 int
	}
	GetuidStub        func() int
	getuidMutex       sync.RWMutex
	getuidArgsForCall []struct {
	}
	getuidReturns struct {
		result1 int
	}
	getuidReturnsOnCall map[int]struct {
		result1 int
	}
	GetwdStub        func() (string, error)
	getwdMutex       sync.RWMutex
	getwdArgsForCall []struct {
	}
	getwdReturns struct {
		result1 string
		result2 error
	}
	getwdReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	HostnameStub        func() (string, error)
	hostnameMutex       sync.RWMutex
	hostnameArgsForCall []struct {
	}
	hostnameReturns struct {
		result1 string
		result2 error
	}
	hostnameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	IsExistStub        func(error) bool
	isExistMutex       sync.RWMutex
	isExistArgsForCall []struct {
		arg1 error
	}
	isExistReturns struct {
		result1 bool
	}
	isExistReturnsOnCall map[int]struct {
		result1 bool
	}
	IsNotExistStub        func(error) bool
	isNotExistMutex       sync.RWMutex
	isNotExistArgsForCall []struct {
		arg1 error
	}
	isNotExistReturns struct {
		result1 bool
	}
	isNotExistReturnsOnCall map[int]struct {
		result1 bool
	}
	IsPathSeparatorStub        func(uint8) bool
	isPathSeparatorMutex       sync.RWMutex
	isPathSeparatorArgsForCall []struct {
		arg1 uint8
	}
	isPathSeparatorReturns struct {
		result1 bool
	}
	isPathSeparatorReturnsOnCall map[int]struct {
		result1 bool
	}
	IsPermissionStub        func(error) bool
	isPermissionMutex       sync.RWMutex
	isPermissionArgsForCall []struct {
		arg1 error
	}
	isPermissionReturns struct {
		result1 bool
	}
	isPermissionReturnsOnCall map[int]struct {
		result1 bool
	}
	LchownStub        func(string, int, int) error
	lchownMutex       sync.RWMutex
	lchownArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	lchownReturns struct {
		result1 error
	}
	lchownReturnsOnCall map[int]struct {
		result1 error
	}
	LinkStub        func(string, string) error
	linkMutex       sync.RWMutex
	linkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	linkReturns struct {
		result1 error
	}
	linkReturnsOnCall map[int]struct {
		result1 error
	}
	LookupEnvStub        func(string) (string, bool)
	lookupEnvMutex       sync.RWMutex
	lookupEnvArgsForCall []struct {
		arg1 string
	}
	lookupEnvReturns struct {
		result1 string
		result2 bool
	}
	lookupEnvReturnsOnCall map[int]struct {
		result1 string
		result2 bool
	}
	LstatStub        func(string) (os.FileInfo, error)
	lstatMutex       sync.RWMutex
	lstatArgsForCall []struct {
		arg1 string
	}
	lstatReturns struct {
		result1 os.FileInfo
		result2 error
	}
	lstatReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	MkdirStub        func(string, os.FileMode) error
	mkdirMutex       sync.RWMutex
	mkdirArgsForCall []struct {
		arg1 string
		arg2 os.FileMode
	}
	mkdirReturns struct {
		result1 error
	}
	mkdirReturnsOnCall map[int]struct {
		result1 error
	}
	MkdirAllStub        func(string, os.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		arg1 string
		arg2 os.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	mkdirAllReturnsOnCall map[int]struct {
		result1 error
	}
	NewFileStub        func(uintptr, string) osshim.File
	newFileMutex       sync.RWMutex
	newFileArgsForCall []struct {
		arg1 uintptr
		arg2 string
	}
	newFileReturns struct {
		result1 osshim.File
	}
	newFileReturnsOnCall map[int]struct {
		result1 osshim.File
	}
	NewSyscallErrorStub        func(string, error) error
	newSyscallErrorMutex       sync.RWMutex
	newSyscallErrorArgsForCall []struct {
		arg1 string
		arg2 error
	}
	newSyscallErrorReturns struct {
		result1 error
	}
	newSyscallErrorReturnsOnCall map[int]struct {
		result1 error
	}
	OpenStub        func(string) (osshim.File, error)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		arg1 string
	}
	openReturns struct {
		result1 osshim.File
		result2 error
	}
	openReturnsOnCall map[int]struct {
		result1 osshim.File
		result2 error
	}
	OpenFileStub        func(string, int, os.FileMode) (osshim.File, error)
	openFileMutex       sync.RWMutex
	openFileArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 os.FileMode
	}
	openFileReturns struct {
		result1 osshim.File
		result2 error
	}
	openFileReturnsOnCall map[int]struct {
		result1 osshim.File
		result2 error
	}
	PipeStub        func() (osshim.File, osshim.File, error)
	pipeMutex       sync.RWMutex
	pipeArgsForCall []struct {
	}
	pipeReturns struct {
		result1 osshim.File
		result2 osshim.File
		result3 error
	}
	pipeReturnsOnCall map[int]struct {
		result1 osshim.File
		result2 osshim.File
		result3 error
	}
	ReadlinkStub        func(string) (string, error)
	readlinkMutex       sync.RWMutex
	readlinkArgsForCall []struct {
		arg1 string
	}
	readlinkReturns struct {
		result1 string
		result2 error
	}
	readlinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RemoveStub        func(string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAllStub        func(string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		arg1 string
	}
	removeAllReturns struct {
		result1 error
	}
	removeAllReturnsOnCall map[int]struct {
		result1 error
	}
	RenameStub        func(string, string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	SameFileStub        func(os.FileInfo, os.FileInfo) bool
	sameFileMutex       sync.RWMutex
	sameFileArgsForCall []struct {
		arg1 os.FileInfo
		arg2 os.FileInfo
	}
	sameFileReturns struct {
		result1 bool
	}
	sameFileReturnsOnCall map[int]struct {
		result1 bool
	}
	SetenvStub        func(string, string) error
	setenvMutex       sync.RWMutex
	setenvArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setenvReturns struct {
		result1 error
	}
	setenvReturnsOnCall map[int]struct {
		result1 error
	}
	StartProcessStub        func(string, []string, *os.ProcAttr) (*os.Process, error)
	startProcessMutex       sync.RWMutex
	startProcessArgsForCall []struct {
		arg1 string
		arg2 []string
		arg3 *os.ProcAttr
	}
	startProcessReturns struct {
		result1 *os.Process
		result2 error
	}
	startProcessReturnsOnCall map[int]struct {
		result1 *os.Process
		result2 error
	}
	StatStub        func(string) (os.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 os.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	SymlinkStub        func(string, string) error
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	symlinkReturns struct {
		result1 error
	}
	symlinkReturnsOnCall map[int]struct {
		result1 error
	}
	TempDirStub        func() string
	tempDirMutex       sync.RWMutex
	tempDirArgsForCall []struct {
	}
	tempDirReturns struct {
		result1 string
	}
	tempDirReturnsOnCall map[int]struct {
		result1 string
	}
	TruncateStub        func(string, int64) error
	truncateMutex       sync.RWMutex
	truncateArgsForCall []struct {
		arg1 string
		arg2 int64
	}
	truncateReturns struct {
		result1 error
	}
	truncateReturnsOnCall map[int]struct {
		result1 error
	}
	UnsetenvStub        func(string) error
	unsetenvMutex       sync.RWMutex
	unsetenvArgsForCall []struct {
		arg1 string
	}
	unsetenvReturns struct {
		result1 error
	}
	unsetenvReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOs) Chdir(arg1 string) error {
	fake.chdirMutex.Lock()
	ret, specificReturn := fake.chdirReturnsOnCall[len(fake.chdirArgsForCall)]
	fake.chdirArgsForCall = append(fake.chdirArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Chdir", []interface{}{arg1})
	fake.chdirMutex.Unlock()
	if fake.ChdirStub != nil {
		return fake.ChdirStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.chdirReturns
	return fakeReturns.result1
}

func (fake *FakeOs) ChdirCallCount() int {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	return len(fake.chdirArgsForCall)
}

func (fake *FakeOs) ChdirCalls(stub func(string) error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = stub
}

func (fake *FakeOs) ChdirArgsForCall(i int) string {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	argsForCall := fake.chdirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) ChdirReturns(result1 error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = nil
	fake.chdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChdirReturnsOnCall(i int, result1 error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = nil
	if fake.chdirReturnsOnCall == nil {
		fake.chdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chmod(arg1 string, arg2 os.FileMode) error {
	fake.chmodMutex.Lock()
	ret, specificReturn := fake.chmodReturnsOnCall[len(fake.chmodArgsForCall)]
	fake.chmodArgsForCall = append(fake.chmodArgsForCall, struct {
		arg1 string
		arg2 os.FileMode
	}{arg1, arg2})
	fake.recordInvocation("Chmod", []interface{}{arg1, arg2})
	fake.chmodMutex.Unlock()
	if fake.ChmodStub != nil {
		return fake.ChmodStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.chmodReturns
	return fakeReturns.result1
}

func (fake *FakeOs) ChmodCallCount() int {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return len(fake.chmodArgsForCall)
}

func (fake *FakeOs) ChmodCalls(stub func(string, os.FileMode) error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = stub
}

func (fake *FakeOs) ChmodArgsForCall(i int) (string, os.FileMode) {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	argsForCall := fake.chmodArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) ChmodReturns(result1 error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = nil
	fake.chmodReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChmodReturnsOnCall(i int, result1 error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = nil
	if fake.chmodReturnsOnCall == nil {
		fake.chmodReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chmodReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chown(arg1 string, arg2 int, arg3 int) error {
	fake.chownMutex.Lock()
	ret, specificReturn := fake.chownReturnsOnCall[len(fake.chownArgsForCall)]
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("Chown", []interface{}{arg1, arg2, arg3})
	fake.chownMutex.Unlock()
	if fake.ChownStub != nil {
		return fake.ChownStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.chownReturns
	return fakeReturns.result1
}

func (fake *FakeOs) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeOs) ChownCalls(stub func(string, int, int) error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = stub
}

func (fake *FakeOs) ChownArgsForCall(i int) (string, int, int) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	argsForCall := fake.chownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) ChownReturns(result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChownReturnsOnCall(i int, result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	if fake.chownReturnsOnCall == nil {
		fake.chownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chtimes(arg1 string, arg2 time.Time, arg3 time.Time) error {
	fake.chtimesMutex.Lock()
	ret, specificReturn := fake.chtimesReturnsOnCall[len(fake.chtimesArgsForCall)]
	fake.chtimesArgsForCall = append(fake.chtimesArgsForCall, struct {
		arg1 string
		arg2 time.Time
		arg3 time.Time
	}{arg1, arg2, arg3})
	fake.recordInvocation("Chtimes", []interface{}{arg1, arg2, arg3})
	fake.chtimesMutex.Unlock()
	if fake.ChtimesStub != nil {
		return fake.ChtimesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.chtimesReturns
	return fakeReturns.result1
}

func (fake *FakeOs) ChtimesCallCount() int {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	return len(fake.chtimesArgsForCall)
}

func (fake *FakeOs) ChtimesCalls(stub func(string, time.Time, time.Time) error) {
	fake.chtimesMutex.Lock()
	defer fake.chtimesMutex.Unlock()
	fake.ChtimesStub = stub
}

func (fake *FakeOs) ChtimesArgsForCall(i int) (string, time.Time, time.Time) {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	argsForCall := fake.chtimesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) ChtimesReturns(result1 error) {
	fake.chtimesMutex.Lock()
	defer fake.chtimesMutex.Unlock()
	fake.ChtimesStub = nil
	fake.chtimesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChtimesReturnsOnCall(i int, result1 error) {
	fake.chtimesMutex.Lock()
	defer fake.chtimesMutex.Unlock()
	fake.ChtimesStub = nil
	if fake.chtimesReturnsOnCall == nil {
		fake.chtimesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chtimesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Clearenv() {
	fake.clearenvMutex.Lock()
	fake.clearenvArgsForCall = append(fake.clearenvArgsForCall, struct {
	}{})
	fake.recordInvocation("Clearenv", []interface{}{})
	fake.clearenvMutex.Unlock()
	if fake.ClearenvStub != nil {
		fake.ClearenvStub()
	}
}

func (fake *FakeOs) ClearenvCallCount() int {
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	return len(fake.clearenvArgsForCall)
}

func (fake *FakeOs) ClearenvCalls(stub func()) {
	fake.clearenvMutex.Lock()
	defer fake.clearenvMutex.Unlock()
	fake.ClearenvStub = stub
}

func (fake *FakeOs) Create(arg1 string) (osshim.File, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeOs) CreateCalls(stub func(string) (osshim.File, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeOs) CreateArgsForCall(i int) string {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) CreateReturns(result1 osshim.File, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) CreateReturnsOnCall(i int, result1 osshim.File, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 osshim.File
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Environ() []string {
	fake.environMutex.Lock()
	ret, specificReturn := fake.environReturnsOnCall[len(fake.environArgsForCall)]
	fake.environArgsForCall = append(fake.environArgsForCall, struct {
	}{})
	fake.recordInvocation("Environ", []interface{}{})
	fake.environMutex.Unlock()
	if fake.EnvironStub != nil {
		return fake.EnvironStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.environReturns
	return fakeReturns.result1
}

func (fake *FakeOs) EnvironCallCount() int {
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	return len(fake.environArgsForCall)
}

func (fake *FakeOs) EnvironCalls(stub func() []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = stub
}

func (fake *FakeOs) EnvironReturns(result1 []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = nil
	fake.environReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeOs) EnvironReturnsOnCall(i int, result1 []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = nil
	if fake.environReturnsOnCall == nil {
		fake.environReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.environReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeOs) Exit(arg1 int) {
	fake.exitMutex.Lock()
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Exit", []interface{}{arg1})
	fake.exitMutex.Unlock()
	if fake.ExitStub != nil {
		fake.ExitStub(arg1)
	}
}

func (fake *FakeOs) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakeOs) ExitCalls(stub func(int)) {
	fake.exitMutex.Lock()
	defer fake.exitMutex.Unlock()
	fake.ExitStub = stub
}

func (fake *FakeOs) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	argsForCall := fake.exitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) Expand(arg1 string, arg2 func(string) string) string {
	fake.expandMutex.Lock()
	ret, specificReturn := fake.expandReturnsOnCall[len(fake.expandArgsForCall)]
	fake.expandArgsForCall = append(fake.expandArgsForCall, struct {
		arg1 string
		arg2 func(string) string
	}{arg1, arg2})
	fake.recordInvocation("Expand", []interface{}{arg1, arg2})
	fake.expandMutex.Unlock()
	if fake.ExpandStub != nil {
		return fake.ExpandStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.expandReturns
	return fakeReturns.result1
}

func (fake *FakeOs) ExpandCallCount() int {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	return len(fake.expandArgsForCall)
}

func (fake *FakeOs) ExpandCalls(stub func(string, func(string) string) string) {
	fake.expandMutex.Lock()
	defer fake.expandMutex.Unlock()
	fake.ExpandStub = stub
}

func (fake *FakeOs) ExpandArgsForCall(i int) (string, func(string) string) {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	argsForCall := fake.expandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) ExpandReturns(result1 string) {
	fake.expandMutex.Lock()
	defer fake.expandMutex.Unlock()
	fake.ExpandStub = nil
	fake.expandReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) ExpandReturnsOnCall(i int, result1 string) {
	fake.expandMutex.Lock()
	defer fake.expandMutex.Unlock()
	fake.ExpandStub = nil
	if fake.expandReturnsOnCall == nil {
		fake.expandReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.expandReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) ExpandEnv(arg1 string) string {
	fake.expandEnvMutex.Lock()
	ret, specificReturn := fake.expandEnvReturnsOnCall[len(fake.expandEnvArgsForCall)]
	fake.expandEnvArgsForCall = append(fake.expandEnvArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ExpandEnv", []interface{}{arg1})
	fake.expandEnvMutex.Unlock()
	if fake.ExpandEnvStub != nil {
		return fake.ExpandEnvStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.expandEnvReturns
	return fakeReturns.result1
}

func (fake *FakeOs) ExpandEnvCallCount() int {
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	return len(fake.expandEnvArgsForCall)
}

func (fake *FakeOs) ExpandEnvCalls(stub func(string) string) {
	fake.expandEnvMutex.Lock()
	defer fake.expandEnvMutex.Unlock()
	fake.ExpandEnvStub = stub
}

func (fake *FakeOs) ExpandEnvArgsForCall(i int) string {
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	argsForCall := fake.expandEnvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) ExpandEnvReturns(result1 string) {
	fake.expandEnvMutex.Lock()
	defer fake.expandEnvMutex.Unlock()
	fake.ExpandEnvStub = nil
	fake.expandEnvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) ExpandEnvReturnsOnCall(i int, result1 string) {
	fake.expandEnvMutex.Lock()
	defer fake.expandEnvMutex.Unlock()
	fake.ExpandEnvStub = nil
	if fake.expandEnvReturnsOnCall == nil {
		fake.expandEnvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.expandEnvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) FindProcess(arg1 int) (*os.Process, error) {
	fake.findProcessMutex.Lock()
	ret, specificReturn := fake.findProcessReturnsOnCall[len(fake.findProcessArgsForCall)]
	fake.findProcessArgsForCall = append(fake.findProcessArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FindProcess", []interface{}{arg1})
	fake.findProcessMutex.Unlock()
	if fake.FindProcessStub != nil {
		return fake.FindProcessStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findProcessReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) FindProcessCallCount() int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	return len(fake.findProcessArgsForCall)
}

func (fake *FakeOs) FindProcessCalls(stub func(int) (*os.Process, error)) {
	fake.findProcessMutex.Lock()
	defer fake.findProcessMutex.Unlock()
	fake.FindProcessStub = stub
}

func (fake *FakeOs) FindProcessArgsForCall(i int) int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	argsForCall := fake.findProcessArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) FindProcessReturns(result1 *os.Process, result2 error) {
	fake.findProcessMutex.Lock()
	defer fake.findProcessMutex.Unlock()
	fake.FindProcessStub = nil
	fake.findProcessReturns = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) FindProcessReturnsOnCall(i int, result1 *os.Process, result2 error) {
	fake.findProcessMutex.Lock()
	defer fake.findProcessMutex.Unlock()
	fake.FindProcessStub = nil
	if fake.findProcessReturnsOnCall == nil {
		fake.findProcessReturnsOnCall = make(map[int]struct {
			result1 *os.Process
			result2 error
		})
	}
	fake.findProcessReturnsOnCall[i] = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Getegid() int {
	fake.getegidMutex.Lock()
	ret, specificReturn := fake.getegidReturnsOnCall[len(fake.getegidArgsForCall)]
	fake.getegidArgsForCall = append(fake.getegidArgsForCall, struct {
	}{})
	fake.recordInvocation("Getegid", []interface{}{})
	fake.getegidMutex.Unlock()
	if fake.GetegidStub != nil {
		return fake.GetegidStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getegidReturns
	return fakeReturns.result1
}

func (fake *FakeOs) GetegidCallCount() int {
	fake.getegidMutex.RLock()
	defer fake.getegidMutex.RUnlock()
	return len(fake.getegidArgsForCall)
}

func (fake *FakeOs) GetegidCalls(stub func() int) {
	fake.getegidMutex.Lock()
	defer fake.getegidMutex.Unlock()
	fake.GetegidStub = stub
}

func (fake *FakeOs) GetegidReturns(result1 int) {
	fake.getegidMutex.Lock()
	defer fake.getegidMutex.Unlock()
	fake.GetegidStub = nil
	fake.getegidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetegidReturnsOnCall(i int, result1 int) {
	fake.getegidMutex.Lock()
	defer fake.getegidMutex.Unlock()
	fake.GetegidStub = nil
	if fake.getegidReturnsOnCall == nil {
		fake.getegidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getegidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getenv(arg1 string) string {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Getenv", []interface{}{arg1})
	fake.getenvMutex.Unlock()
	if fake.GetenvStub != nil {
		return fake.GetenvStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getenvReturns
	return fakeReturns.result1
}

func (fake *FakeOs) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeOs) GetenvCalls(stub func(string) string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = stub
}

func (fake *FakeOs) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	argsForCall := fake.getenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) GetenvReturns(result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) GetenvReturnsOnCall(i int, result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) Geteuid() int {
	fake.geteuidMutex.Lock()
	ret, specificReturn := fake.geteuidReturnsOnCall[len(fake.geteuidArgsForCall)]
	fake.geteuidArgsForCall = append(fake.geteuidArgsForCall, struct {
	}{})
	fake.recordInvocation("Geteuid", []interface{}{})
	fake.geteuidMutex.Unlock()
	if fake.GeteuidStub != nil {
		return fake.GeteuidStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.geteuidReturns
	return fakeReturns.result1
}

func (fake *FakeOs) GeteuidCallCount() int {
	fake.geteuidMutex.RLock()
	defer fake.geteuidMutex.RUnlock()
	return len(fake.geteuidArgsForCall)
}

func (fake *FakeOs) GeteuidCalls(stub func() int) {
	fake.geteuidMutex.Lock()
	defer fake.geteuidMutex.Unlock()
	fake.GeteuidStub = stub
}

func (fake *FakeOs) GeteuidReturns(result1 int) {
	fake.geteuidMutex.Lock()
	defer fake.geteuidMutex.Unlock()
	fake.GeteuidStub = nil
	fake.geteuidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GeteuidReturnsOnCall(i int, result1 int) {
	fake.geteuidMutex.Lock()
	defer fake.geteuidMutex.Unlock()
	fake.GeteuidStub = nil
	if fake.geteuidReturnsOnCall == nil {
		fake.geteuidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.geteuidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getgid() int {
	fake.getgidMutex.Lock()
	ret, specificReturn := fake.getgidReturnsOnCall[len(fake.getgidArgsForCall)]
	fake.getgidArgsForCall = append(fake.getgidArgsForCall, struct {
	}{})
	fake.recordInvocation("Getgid", []interface{}{})
	fake.getgidMutex.Unlock()
	if fake.GetgidStub != nil {
		return fake.GetgidStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getgidReturns
	return fakeReturns.result1
}

func (fake *FakeOs) GetgidCallCount() int {
	fake.getgidMutex.RLock()
	defer fake.getgidMutex.RUnlock()
	return len(fake.getgidArgsForCall)
}

func (fake *FakeOs) GetgidCalls(stub func() int) {
	fake.getgidMutex.Lock()
	defer fake.getgidMutex.Unlock()
	fake.GetgidStub = stub
}

func (fake *FakeOs) GetgidReturns(result1 int) {
	fake.getgidMutex.Lock()
	defer fake.getgidMutex.Unlock()
	fake.GetgidStub = nil
	fake.getgidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetgidReturnsOnCall(i int, result1 int) {
	fake.getgidMutex.Lock()
	defer fake.getgidMutex.Unlock()
	fake.GetgidStub = nil
	if fake.getgidReturnsOnCall == nil {
		fake.getgidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getgidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getgroups() ([]int, error) {
	fake.getgroupsMutex.Lock()
	ret, specificReturn := fake.getgroupsReturnsOnCall[len(fake.getgroupsArgsForCall)]
	fake.getgroupsArgsForCall = append(fake.getgroupsArgsForCall, struct {
	}{})
	fake.recordInvocation("Getgroups", []interface{}{})
	fake.getgroupsMutex.Unlock()
	if fake.GetgroupsStub != nil {
		return fake.GetgroupsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getgroupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) GetgroupsCallCount() int {
	fake.getgroupsMutex.RLock()
	defer fake.getgroupsMutex.RUnlock()
	return len(fake.getgroupsArgsForCall)
}

func (fake *FakeOs) GetgroupsCalls(stub func() ([]int, error)) {
	fake.getgroupsMutex.Lock()
	defer fake.getgroupsMutex.Unlock()
	fake.GetgroupsStub = stub
}

func (fake *FakeOs) GetgroupsReturns(result1 []int, result2 error) {
	fake.getgroupsMutex.Lock()
	defer fake.getgroupsMutex.Unlock()
	fake.GetgroupsStub = nil
	fake.getgroupsReturns = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) GetgroupsReturnsOnCall(i int, result1 []int, result2 error) {
	fake.getgroupsMutex.Lock()
	defer fake.getgroupsMutex.Unlock()
	fake.GetgroupsStub = nil
	if fake.getgroupsReturnsOnCall == nil {
		fake.getgroupsReturnsOnCall = make(map[int]struct {
			result1 []int
			result2 error
		})
	}
	fake.getgroupsReturnsOnCall[i] = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Getpagesize() int {
	fake.getpagesizeMutex.Lock()
	ret, specificReturn := fake.getpagesizeReturnsOnCall[len(fake.getpagesizeArgsForCall)]
	fake.getpagesizeArgsForCall = append(fake.getpagesizeArgsForCall, struct {
	}{})
	fake.recordInvocation("Getpagesize", []interface{}{})
	fake.getpagesizeMutex.Unlock()
	if fake.GetpagesizeStub != nil {
		return fake.GetpagesizeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getpagesizeReturns
	return fakeReturns.result1
}

func (fake *FakeOs) GetpagesizeCallCount() int {
	fake.getpagesizeMutex.RLock()
	defer fake.getpagesizeMutex.RUnlock()
	return len(fake.getpagesizeArgsForCall)
}

func (fake *FakeOs) GetpagesizeCalls(stub func() int) {
	fake.getpagesizeMutex.Lock()
	defer fake.getpagesizeMutex.Unlock()
	fake.GetpagesizeStub = stub
}

func (fake *FakeOs) GetpagesizeReturns(result1 int) {
	fake.getpagesizeMutex.Lock()
	defer fake.getpagesizeMutex.Unlock()
	fake.GetpagesizeStub = nil
	fake.getpagesizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetpagesizeReturnsOnCall(i int, result1 int) {
	fake.getpagesizeMutex.Lock()
	defer fake.getpagesizeMutex.Unlock()
	fake.GetpagesizeStub = nil
	if fake.getpagesizeReturnsOnCall == nil {
		fake.getpagesizeReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getpagesizeReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getpid() int {
	fake.getpidMutex.Lock()
	ret, specificReturn := fake.getpidReturnsOnCall[len(fake.getpidArgsForCall)]
	fake.getpidArgsForCall = append(fake.getpidArgsForCall, struct {
	}{})
	fake.recordInvocation("Getpid", []interface{}{})
	fake.getpidMutex.Unlock()
	if fake.GetpidStub != nil {
		return fake.GetpidStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getpidReturns
	return fakeReturns.result1
}

func (fake *FakeOs) GetpidCallCount() int {
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	return len(fake.getpidArgsForCall)
}

func (fake *FakeOs) GetpidCalls(stub func() int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = stub
}

func (fake *FakeOs) GetpidReturns(result1 int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = nil
	fake.getpidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetpidReturnsOnCall(i int, result1 int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = nil
	if fake.getpidReturnsOnCall == nil {
		fake.getpidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getpidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getppid() int {
	fake.getppidMutex.Lock()
	ret, specificReturn := fake.getppidReturnsOnCall[len(fake.getppidArgsForCall)]
	fake.getppidArgsForCall = append(fake.getppidArgsForCall, struct {
	}{})
	fake.recordInvocation("Getppid", []interface{}{})
	fake.getppidMutex.Unlock()
	if fake.GetppidStub != nil {
		return fake.GetppidStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getppidReturns
	return fakeReturns.result1
}

func (fake *FakeOs) GetppidCallCount() int {
	fake.getppidMutex.RLock()
	defer fake.getppidMutex.RUnlock()
	return len(fake.getppidArgsForCall)
}

func (fake *FakeOs) GetppidCalls(stub func() int) {
	fake.getppidMutex.Lock()
	defer fake.getppidMutex.Unlock()
	fake.GetppidStub = stub
}

func (fake *FakeOs) GetppidReturns(result1 int) {
	fake.getppidMutex.Lock()
	defer fake.getppidMutex.Unlock()
	fake.GetppidStub = nil
	fake.getppidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetppidReturnsOnCall(i int, result1 int) {
	fake.getppidMutex.Lock()
	defer fake.getppidMutex.Unlock()
	fake.GetppidStub = nil
	if fake.getppidReturnsOnCall == nil {
		fake.getppidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getppidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getuid() int {
	fake.getuidMutex.Lock()
	ret, specificReturn := fake.getuidReturnsOnCall[len(fake.getuidArgsForCall)]
	fake.getuidArgsForCall = append(fake.getuidArgsForCall, struct {
	}{})
	fake.recordInvocation("Getuid", []interface{}{})
	fake.getuidMutex.Unlock()
	if fake.GetuidStub != nil {
		return fake.GetuidStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getuidReturns
	return fakeReturns.result1
}

func (fake *FakeOs) GetuidCallCount() int {
	fake.getuidMutex.RLock()
	defer fake.getuidMutex.RUnlock()
	return len(fake.getuidArgsForCall)
}

func (fake *FakeOs) GetuidCalls(stub func() int) {
	fake.getuidMutex.Lock()
	defer fake.getuidMutex.Unlock()
	fake.GetuidStub = stub
}

func (fake *FakeOs) GetuidReturns(result1 int) {
	fake.getuidMutex.Lock()
	defer fake.getuidMutex.Unlock()
	fake.GetuidStub = nil
	fake.getuidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetuidReturnsOnCall(i int, result1 int) {
	fake.getuidMutex.Lock()
	defer fake.getuidMutex.Unlock()
	fake.GetuidStub = nil
	if fake.getuidReturnsOnCall == nil {
		fake.getuidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getuidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getwd() (string, error) {
	fake.getwdMutex.Lock()
	ret, specificReturn := fake.getwdReturnsOnCall[len(fake.getwdArgsForCall)]
	fake.getwdArgsForCall = append(fake.getwdArgsForCall, struct {
	}{})
	fake.recordInvocation("Getwd", []interface{}{})
	fake.getwdMutex.Unlock()
	if fake.GetwdStub != nil {
		return fake.GetwdStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getwdReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) GetwdCallCount() int {
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	return len(fake.getwdArgsForCall)
}

func (fake *FakeOs) GetwdCalls(stub func() (string, error)) {
	fake.getwdMutex.Lock()
	defer fake.getwdMutex.Unlock()
	fake.GetwdStub = stub
}

func (fake *FakeOs) GetwdReturns(result1 string, result2 error) {
	fake.getwdMutex.Lock()
	defer fake.getwdMutex.Unlock()
	fake.GetwdStub = nil
	fake.getwdReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) GetwdReturnsOnCall(i int, result1 string, result2 error) {
	fake.getwdMutex.Lock()
	defer fake.getwdMutex.Unlock()
	fake.GetwdStub = nil
	if fake.getwdReturnsOnCall == nil {
		fake.getwdReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getwdReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Hostname() (string, error) {
	fake.hostnameMutex.Lock()
	ret, specificReturn := fake.hostnameReturnsOnCall[len(fake.hostnameArgsForCall)]
	fake.hostnameArgsForCall = append(fake.hostnameArgsForCall, struct {
	}{})
	fake.recordInvocation("Hostname", []interface{}{})
	fake.hostnameMutex.Unlock()
	if fake.HostnameStub != nil {
		return fake.HostnameStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hostnameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) HostnameCallCount() int {
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	return len(fake.hostnameArgsForCall)
}

func (fake *FakeOs) HostnameCalls(stub func() (string, error)) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = stub
}

func (fake *FakeOs) HostnameReturns(result1 string, result2 error) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = nil
	fake.hostnameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) HostnameReturnsOnCall(i int, result1 string, result2 error) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = nil
	if fake.hostnameReturnsOnCall == nil {
		fake.hostnameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.hostnameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) IsExist(arg1 error) bool {
	fake.isExistMutex.Lock()
	ret, specificReturn := fake.isExistReturnsOnCall[len(fake.isExistArgsForCall)]
	fake.isExistArgsForCall = append(fake.isExistArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("IsExist", []interface{}{arg1})
	fake.isExistMutex.Unlock()
	if fake.IsExistStub != nil {
		return fake.IsExistStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isExistReturns
	return fakeReturns.result1
}

func (fake *FakeOs) IsExistCallCount() int {
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	return len(fake.isExistArgsForCall)
}

func (fake *FakeOs) IsExistCalls(stub func(error) bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = stub
}

func (fake *FakeOs) IsExistArgsForCall(i int) error {
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	argsForCall := fake.isExistArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsExistReturns(result1 bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = nil
	fake.isExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsExistReturnsOnCall(i int, result1 bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = nil
	if fake.isExistReturnsOnCall == nil {
		fake.isExistReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isExistReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsNotExist(arg1 error) bool {
	fake.isNotExistMutex.Lock()
	ret, specificReturn := fake.isNotExistReturnsOnCall[len(fake.isNotExistArgsForCall)]
	fake.isNotExistArgsForCall = append(fake.isNotExistArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("IsNotExist", []interface{}{arg1})
	fake.isNotExistMutex.Unlock()
	if fake.IsNotExistStub != nil {
		return fake.IsNotExistStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isNotExistReturns
	return fakeReturns.result1
}

func (fake *FakeOs) IsNotExistCallCount() int {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	return len(fake.isNotExistArgsForCall)
}

func (fake *FakeOs) IsNotExistCalls(stub func(error) bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = stub
}

func (fake *FakeOs) IsNotExistArgsForCall(i int) error {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	argsForCall := fake.isNotExistArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsNotExistReturns(result1 bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = nil
	fake.isNotExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsNotExistReturnsOnCall(i int, result1 bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = nil
	if fake.isNotExistReturnsOnCall == nil {
		fake.isNotExistReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isNotExistReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPathSeparator(arg1 uint8) bool {
	fake.isPathSeparatorMutex.Lock()
	ret, specificReturn := fake.isPathSeparatorReturnsOnCall[len(fake.isPathSeparatorArgsForCall)]
	fake.isPathSeparatorArgsForCall = append(fake.isPathSeparatorArgsForCall, struct {
		arg1 uint8
	}{arg1})
	fake.recordInvocation("IsPathSeparator", []interface{}{arg1})
	fake.isPathSeparatorMutex.Unlock()
	if fake.IsPathSeparatorStub != nil {
		return fake.IsPathSeparatorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isPathSeparatorReturns
	return fakeReturns.result1
}

func (fake *FakeOs) IsPathSeparatorCallCount() int {
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	return len(fake.isPathSeparatorArgsForCall)
}

func (fake *FakeOs) IsPathSeparatorCalls(stub func(uint8) bool) {
	fake.isPathSeparatorMutex.Lock()
	defer fake.isPathSeparatorMutex.Unlock()
	fake.IsPathSeparatorStub = stub
}

func (fake *FakeOs) IsPathSeparatorArgsForCall(i int) uint8 {
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	argsForCall := fake.isPathSeparatorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsPathSeparatorReturns(result1 bool) {
	fake.isPathSeparatorMutex.Lock()
	defer fake.isPathSeparatorMutex.Unlock()
	fake.IsPathSeparatorStub = nil
	fake.isPathSeparatorReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPathSeparatorReturnsOnCall(i int, result1 bool) {
	fake.isPathSeparatorMutex.Lock()
	defer fake.isPathSeparatorMutex.Unlock()
	fake.IsPathSeparatorStub = nil
	if fake.isPathSeparatorReturnsOnCall == nil {
		fake.isPathSeparatorReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPathSeparatorReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPermission(arg1 error) bool {
	fake.isPermissionMutex.Lock()
	ret, specificReturn := fake.isPermissionReturnsOnCall[len(fake.isPermissionArgsForCall)]
	fake.isPermissionArgsForCall = append(fake.isPermissionArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("IsPermission", []interface{}{arg1})
	fake.isPermissionMutex.Unlock()
	if fake.IsPermissionStub != nil {
		return fake.IsPermissionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isPermissionReturns
	return fakeReturns.result1
}

func (fake *FakeOs) IsPermissionCallCount() int {
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	return len(fake.isPermissionArgsForCall)
}

func (fake *FakeOs) IsPermissionCalls(stub func(error) bool) {
	fake.isPermissionMutex.Lock()
	defer fake.isPermissionMutex.Unlock()
	fake.IsPermissionStub = stub
}

func (fake *FakeOs) IsPermissionArgsForCall(i int) error {
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	argsForCall := fake.isPermissionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsPermissionReturns(result1 bool) {
	fake.isPermissionMutex.Lock()
	defer fake.isPermissionMutex.Unlock()
	fake.IsPermissionStub = nil
	fake.isPermissionReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPermissionReturnsOnCall(i int, result1 bool) {
	fake.isPermissionMutex.Lock()
	defer fake.isPermissionMutex.Unlock()
	fake.IsPermissionStub = nil
	if fake.isPermissionReturnsOnCall == nil {
		fake.isPermissionReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPermissionReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) Lchown(arg1 string, arg2 int, arg3 int) error {
	fake.lchownMutex.Lock()
	ret, specificReturn := fake.lchownReturnsOnCall[len(fake.lchownArgsForCall)]
	fake.lchownArgsForCall = append(fake.lchownArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("Lchown", []interface{}{arg1, arg2, arg3})
	fake.lchownMutex.Unlock()
	if fake.LchownStub != nil {
		return fake.LchownStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.lchownReturns
	return fakeReturns.result1
}

func (fake *FakeOs) LchownCallCount() int {
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	return len(fake.lchownArgsForCall)
}

func (fake *FakeOs) LchownCalls(stub func(string, int, int) error) {
	fake.lchownMutex.Lock()
	defer fake.lchownMutex.Unlock()
	fake.LchownStub = stub
}

func (fake *FakeOs) LchownArgsForCall(i int) (string, int, int) {
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	argsForCall := fake.lchownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) LchownReturns(result1 error) {
	fake.lchownMutex.Lock()
	defer fake.lchownMutex.Unlock()
	fake.LchownStub = nil
	fake.lchownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) LchownReturnsOnCall(i int, result1 error) {
	fake.lchownMutex.Lock()
	defer fake.lchownMutex.Unlock()
	fake.LchownStub = nil
	if fake.lchownReturnsOnCall == nil {
		fake.lchownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lchownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Link(arg1 string, arg2 string) error {
	fake.linkMutex.Lock()
	ret, specificReturn := fake.linkReturnsOnCall[len(fake.linkArgsForCall)]
	fake.linkArgsForCall = append(fake.linkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Link", []interface{}{arg1, arg2})
	fake.linkMutex.Unlock()
	if fake.LinkStub != nil {
		return fake.LinkStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.linkReturns
	return fakeReturns.result1
}

func (fake *FakeOs) LinkCallCount() int {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return len(fake.linkArgsForCall)
}

func (fake *FakeOs) LinkCalls(stub func(string, string) error) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = stub
}

func (fake *FakeOs) LinkArgsForCall(i int) (string, string) {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	argsForCall := fake.linkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) LinkReturns(result1 error) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = nil
	fake.linkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) LinkReturnsOnCall(i int, result1 error) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = nil
	if fake.linkReturnsOnCall == nil {
		fake.linkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.linkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) LookupEnv(arg1 string) (string, bool) {
	fake.lookupEnvMutex.Lock()
	ret, specificReturn := fake.lookupEnvReturnsOnCall[len(fake.lookupEnvArgsForCall)]
	fake.lookupEnvArgsForCall = append(fake.lookupEnvArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("LookupEnv", []interface{}{arg1})
	fake.lookupEnvMutex.Unlock()
	if fake.LookupEnvStub != nil {
		return fake.LookupEnvStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.lookupEnvReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) LookupEnvCallCount() int {
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	return len(fake.lookupEnvArgsForCall)
}

func (fake *FakeOs) LookupEnvCalls(stub func(string) (string, bool)) {
	fake.lookupEnvMutex.Lock()
	defer fake.lookupEnvMutex.Unlock()
	fake.LookupEnvStub = stub
}

func (fake *FakeOs) LookupEnvArgsForCall(i int) string {
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	argsForCall := fake.lookupEnvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) LookupEnvReturns(result1 string, result2 bool) {
	fake.lookupEnvMutex.Lock()
	defer fake.lookupEnvMutex.Unlock()
	fake.LookupEnvStub = nil
	fake.lookupEnvReturns = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeOs) LookupEnvReturnsOnCall(i int, result1 string, result2 bool) {
	fake.lookupEnvMutex.Lock()
	defer fake.lookupEnvMutex.Unlock()
	fake.LookupEnvStub = nil
	if fake.lookupEnvReturnsOnCall == nil {
		fake.lookupEnvReturnsOnCall = make(map[int]struct {
			result1 string
			result2 bool
		})
	}
	fake.lookupEnvReturnsOnCall[i] = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeOs) Lstat(arg1 string) (os.FileInfo, error) {
	fake.lstatMutex.Lock()
	ret, specificReturn := fake.lstatReturnsOnCall[len(fake.lstatArgsForCall)]
	fake.lstatArgsForCall = append(fake.lstatArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Lstat", []interface{}{arg1})
	fake.lstatMutex.Unlock()
	if fake.LstatStub != nil {
		return fake.LstatStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.lstatReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) LstatCallCount() int {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	return len(fake.lstatArgsForCall)
}

func (fake *FakeOs) LstatCalls(stub func(string) (os.FileInfo, error)) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = stub
}

func (fake *FakeOs) LstatArgsForCall(i int) string {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	argsForCall := fake.lstatArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) LstatReturns(result1 os.FileInfo, result2 error) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = nil
	fake.lstatReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) LstatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = nil
	if fake.lstatReturnsOnCall == nil {
		fake.lstatReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.lstatReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Mkdir(arg1 string, arg2 os.FileMode) error {
	fake.mkdirMutex.Lock()
	ret, specificReturn := fake.mkdirReturnsOnCall[len(fake.mkdirArgsForCall)]
	fake.mkdirArgsForCall = append(fake.mkdirArgsForCall, struct {
		arg1 string
		arg2 os.FileMode
	}{arg1, arg2})
	fake.recordInvocation("Mkdir", []interface{}{arg1, arg2})
	fake.mkdirMutex.Unlock()
	if fake.MkdirStub != nil {
		return fake.MkdirStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mkdirReturns
	return fakeReturns.result1
}

func (fake *FakeOs) MkdirCallCount() int {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return len(fake.mkdirArgsForCall)
}

func (fake *FakeOs) MkdirCalls(stub func(string, os.FileMode) error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = stub
}

func (fake *FakeOs) MkdirArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	argsForCall := fake.mkdirArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) MkdirReturns(result1 error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = nil
	fake.mkdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirReturnsOnCall(i int, result1 error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = nil
	if fake.mkdirReturnsOnCall == nil {
		fake.mkdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirAll(arg1 string, arg2 os.FileMode) error {
	fake.mkdirAllMutex.Lock()
	ret, specificReturn := fake.mkdirAllReturnsOnCall[len(fake.mkdirAllArgsForCall)]
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		arg1 string
		arg2 os.FileMode
	}{arg1, arg2})
	fake.recordInvocation("MkdirAll", []interface{}{arg1, arg2})
	fake.mkdirAllMutex.Unlock()
	if fake.MkdirAllStub != nil {
		return fake.MkdirAllStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mkdirAllReturns
	return fakeReturns.result1
}

func (fake *FakeOs) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeOs) MkdirAllCalls(stub func(string, os.FileMode) error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = stub
}

func (fake *FakeOs) MkdirAllArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	argsForCall := fake.mkdirAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) MkdirAllReturns(result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirAllReturnsOnCall(i int, result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	if fake.mkdirAllReturnsOnCall == nil {
		fake.mkdirAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) NewFile(arg1 uintptr, arg2 string) osshim.File {
	fake.newFileMutex.Lock()
	ret, specificReturn := fake.newFileReturnsOnCall[len(fake.newFileArgsForCall)]
	fake.newFileArgsForCall = append(fake.newFileArgsForCall, struct {
		arg1 uintptr
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("NewFile", []interface{}{arg1, arg2})
	fake.newFileMutex.Unlock()
	if fake.NewFileStub != nil {
		return fake.NewFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newFileReturns
	return fakeReturns.result1
}

func (fake *FakeOs) NewFileCallCount() int {
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	return len(fake.newFileArgsForCall)
}

func (fake *FakeOs) NewFileCalls(stub func(uintptr, string) osshim.File) {
	fake.newFileMutex.Lock()
	defer fake.newFileMutex.Unlock()
	fake.NewFileStub = stub
}

func (fake *FakeOs) NewFileArgsForCall(i int) (uintptr, string) {
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	argsForCall := fake.newFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) NewFileReturns(result1 osshim.File) {
	fake.newFileMutex.Lock()
	defer fake.newFileMutex.Unlock()
	fake.NewFileStub = nil
	fake.newFileReturns = struct {
		result1 osshim.File
	}{result1}
}

func (fake *FakeOs) NewFileReturnsOnCall(i int, result1 osshim.File) {
	fake.newFileMutex.Lock()
	defer fake.newFileMutex.Unlock()
	fake.NewFileStub = nil
	if fake.newFileReturnsOnCall == nil {
		fake.newFileReturnsOnCall = make(map[int]struct {
			result1 osshim.File
		})
	}
	fake.newFileReturnsOnCall[i] = struct {
		result1 osshim.File
	}{result1}
}

func (fake *FakeOs) NewSyscallError(arg1 string, arg2 error) error {
	fake.newSyscallErrorMutex.Lock()
	ret, specificReturn := fake.newSyscallErrorReturnsOnCall[len(fake.newSyscallErrorArgsForCall)]
	fake.newSyscallErrorArgsForCall = append(fake.newSyscallErrorArgsForCall, struct {
		arg1 string
		arg2 error
	}{arg1, arg2})
	fake.recordInvocation("NewSyscallError", []interface{}{arg1, arg2})
	fake.newSyscallErrorMutex.Unlock()
	if fake.NewSyscallErrorStub != nil {
		return fake.NewSyscallErrorStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newSyscallErrorReturns
	return fakeReturns.result1
}

func (fake *FakeOs) NewSyscallErrorCallCount() int {
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	return len(fake.newSyscallErrorArgsForCall)
}

func (fake *FakeOs) NewSyscallErrorCalls(stub func(string, error) error) {
	fake.newSyscallErrorMutex.Lock()
	defer fake.newSyscallErrorMutex.Unlock()
	fake.NewSyscallErrorStub = stub
}

func (fake *FakeOs) NewSyscallErrorArgsForCall(i int) (string, error) {
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	argsForCall := fake.newSyscallErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) NewSyscallErrorReturns(result1 error) {
	fake.newSyscallErrorMutex.Lock()
	defer fake.newSyscallErrorMutex.Unlock()
	fake.NewSyscallErrorStub = nil
	fake.newSyscallErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) NewSyscallErrorReturnsOnCall(i int, result1 error) {
	fake.newSyscallErrorMutex.Lock()
	defer fake.newSyscallErrorMutex.Unlock()
	fake.NewSyscallErrorStub = nil
	if fake.newSyscallErrorReturnsOnCall == nil {
		fake.newSyscallErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.newSyscallErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Open(arg1 string) (osshim.File, error) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Open", []interface{}{arg1})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.openReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeOs) OpenCalls(stub func(string) (osshim.File, error)) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = stub
}

func (fake *FakeOs) OpenArgsForCall(i int) string {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	argsForCall := fake.openArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) OpenReturns(result1 osshim.File, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) OpenReturnsOnCall(i int, result1 osshim.File, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 osshim.File
			result2 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) OpenFile(arg1 string, arg2 int, arg3 os.FileMode) (osshim.File, error) {
	fake.openFileMutex.Lock()
	ret, specificReturn := fake.openFileReturnsOnCall[len(fake.openFileArgsForCall)]
	fake.openFileArgsForCall = append(fake.openFileArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 os.FileMode
	}{arg1, arg2, arg3})
	fake.recordInvocation("OpenFile", []interface{}{arg1, arg2, arg3})
	fake.openFileMutex.Unlock()
	if fake.OpenFileStub != nil {
		return fake.OpenFileStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.openFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) OpenFileCallCount() int {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return len(fake.openFileArgsForCall)
}

func (fake *FakeOs) OpenFileCalls(stub func(string, int, os.FileMode) (osshim.File, error)) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = stub
}

func (fake *FakeOs) OpenFileArgsForCall(i int) (string, int, os.FileMode) {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	argsForCall := fake.openFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) OpenFileReturns(result1 osshim.File, result2 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	fake.openFileReturns = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) OpenFileReturnsOnCall(i int, result1 osshim.File, result2 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	if fake.openFileReturnsOnCall == nil {
		fake.openFileReturnsOnCall = make(map[int]struct {
			result1 osshim.File
			result2 error
		})
	}
	fake.openFileReturnsOnCall[i] = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Pipe() (osshim.File, osshim.File, error) {
	fake.pipeMutex.Lock()
	ret, specificReturn := fake.pipeReturnsOnCall[len(fake.pipeArgsForCall)]
	fake.pipeArgsForCall = append(fake.pipeArgsForCall, struct {
	}{})
	fake.recordInvocation("Pipe", []interface{}{})
	fake.pipeMutex.Unlock()
	if fake.PipeStub != nil {
		return fake.PipeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pipeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeOs) PipeCallCount() int {
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	return len(fake.pipeArgsForCall)
}

func (fake *FakeOs) PipeCalls(stub func() (osshim.File, osshim.File, error)) {
	fake.pipeMutex.Lock()
	defer fake.pipeMutex.Unlock()
	fake.PipeStub = stub
}

func (fake *FakeOs) PipeReturns(result1 osshim.File, result2 osshim.File, result3 error) {
	fake.pipeMutex.Lock()
	defer fake.pipeMutex.Unlock()
	fake.PipeStub = nil
	fake.pipeReturns = struct {
		result1 osshim.File
		result2 osshim.File
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeOs) PipeReturnsOnCall(i int, result1 osshim.File, result2 osshim.File, result3 error) {
	fake.pipeMutex.Lock()
	defer fake.pipeMutex.Unlock()
	fake.PipeStub = nil
	if fake.pipeReturnsOnCall == nil {
		fake.pipeReturnsOnCall = make(map[int]struct {
			result1 osshim.File
			result2 osshim.File
			result3 error
		})
	}
	fake.pipeReturnsOnCall[i] = struct {
		result1 osshim.File
		result2 osshim.File
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeOs) Readlink(arg1 string) (string, error) {
	fake.readlinkMutex.Lock()
	ret, specificReturn := fake.readlinkReturnsOnCall[len(fake.readlinkArgsForCall)]
	fake.readlinkArgsForCall = append(fake.readlinkArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Readlink", []interface{}{arg1})
	fake.readlinkMutex.Unlock()
	if fake.ReadlinkStub != nil {
		return fake.ReadlinkStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readlinkReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) ReadlinkCallCount() int {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return len(fake.readlinkArgsForCall)
}

func (fake *FakeOs) ReadlinkCalls(stub func(string) (string, error)) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = stub
}

func (fake *FakeOs) ReadlinkArgsForCall(i int) string {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	argsForCall := fake.readlinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) ReadlinkReturns(result1 string, result2 error) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	fake.readlinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) ReadlinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	if fake.readlinkReturnsOnCall == nil {
		fake.readlinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.readlinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Remove(arg1 string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if fake.RemoveStub != nil {
		return fake.RemoveStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeReturns
	return fakeReturns.result1
}

func (fake *FakeOs) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeOs) RemoveCalls(stub func(string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeOs) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RemoveAll(arg1 string) error {
	fake.removeAllMutex.Lock()
	ret, specificReturn := fake.removeAllReturnsOnCall[len(fake.removeAllArgsForCall)]
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RemoveAll", []interface{}{arg1})
	fake.removeAllMutex.Unlock()
	if fake.RemoveAllStub != nil {
		return fake.RemoveAllStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeAllReturns
	return fakeReturns.result1
}

func (fake *FakeOs) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakeOs) RemoveAllCalls(stub func(string) error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = stub
}

func (fake *FakeOs) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	argsForCall := fake.removeAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) RemoveAllReturns(result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RemoveAllReturnsOnCall(i int, result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	if fake.removeAllReturnsOnCall == nil {
		fake.removeAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Rename(arg1 string, arg2 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Rename", []interface{}{arg1, arg2})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renameReturns
	return fakeReturns.result1
}

func (fake *FakeOs) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeOs) RenameCalls(stub func(string, string) error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = stub
}

func (fake *FakeOs) RenameArgsForCall(i int) (string, string) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) RenameReturns(result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RenameReturnsOnCall(i int, result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) SameFile(arg1 os.FileInfo, arg2 os.FileInfo) bool {
	fake.sameFileMutex.Lock()
	ret, specificReturn := fake.sameFileReturnsOnCall[len(fake.sameFileArgsForCall)]
	fake.sameFileArgsForCall = append(fake.sameFileArgsForCall, struct {
		arg1 os.FileInfo
		arg2 os.FileInfo
	}{arg1, arg2})
	fake.recordInvocation("SameFile", []interface{}{arg1, arg2})
	fake.sameFileMutex.Unlock()
	if fake.SameFileStub != nil {
		return fake.SameFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sameFileReturns
	return fakeReturns.result1
}

func (fake *FakeOs) SameFileCallCount() int {
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	return len(fake.sameFileArgsForCall)
}

func (fake *FakeOs) SameFileCalls(stub func(os.FileInfo, os.FileInfo) bool) {
	fake.sameFileMutex.Lock()
	defer fake.sameFileMutex.Unlock()
	fake.SameFileStub = stub
}

func (fake *FakeOs) SameFileArgsForCall(i int) (os.FileInfo, os.FileInfo) {
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	argsForCall := fake.sameFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) SameFileReturns(result1 bool) {
	fake.sameFileMutex.Lock()
	defer fake.sameFileMutex.Unlock()
	fake.SameFileStub = nil
	fake.sameFileReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) SameFileReturnsOnCall(i int, result1 bool) {
	fake.sameFileMutex.Lock()
	defer fake.sameFileMutex.Unlock()
	fake.SameFileStub = nil
	if fake.sameFileReturnsOnCall == nil {
		fake.sameFileReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.sameFileReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) Setenv(arg1 string, arg2 string) error {
	fake.setenvMutex.Lock()
	ret, specificReturn := fake.setenvReturnsOnCall[len(fake.setenvArgsForCall)]
	fake.setenvArgsForCall = append(fake.setenvArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Setenv", []interface{}{arg1, arg2})
	fake.setenvMutex.Unlock()
	if fake.SetenvStub != nil {
		return fake.SetenvStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setenvReturns
	return fakeReturns.result1
}

func (fake *FakeOs) SetenvCallCount() int {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	return len(fake.setenvArgsForCall)
}

func (fake *FakeOs) SetenvCalls(stub func(string, string) error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = stub
}

func (fake *FakeOs) SetenvArgsForCall(i int) (string, string) {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	argsForCall := fake.setenvArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) SetenvReturns(result1 error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = nil
	fake.setenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) SetenvReturnsOnCall(i int, result1 error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = nil
	if fake.setenvReturnsOnCall == nil {
		fake.setenvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setenvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) StartProcess(arg1 string, arg2 []string, arg3 *os.ProcAttr) (*os.Process, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.startProcessMutex.Lock()
	ret, specificReturn := fake.startProcessReturnsOnCall[len(fake.startProcessArgsForCall)]
	fake.startProcessArgsForCall = append(fake.startProcessArgsForCall, struct {
		arg1 string
		arg2 []string
		arg3 *os.ProcAttr
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("StartProcess", []interface{}{arg1, arg2Copy, arg3})
	fake.startProcessMutex.Unlock()
	if fake.StartProcessStub != nil {
		return fake.StartProcessStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.startProcessReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) StartProcessCallCount() int {
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	return len(fake.startProcessArgsForCall)
}

func (fake *FakeOs) StartProcessCalls(stub func(string, []string, *os.ProcAttr) (*os.Process, error)) {
	fake.startProcessMutex.Lock()
	defer fake.startProcessMutex.Unlock()
	fake.StartProcessStub = stub
}

func (fake *FakeOs) StartProcessArgsForCall(i int) (string, []string, *os.ProcAttr) {
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	argsForCall := fake.startProcessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) StartProcessReturns(result1 *os.Process, result2 error) {
	fake.startProcessMutex.Lock()
	defer fake.startProcessMutex.Unlock()
	fake.StartProcessStub = nil
	fake.startProcessReturns = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) StartProcessReturnsOnCall(i int, result1 *os.Process, result2 error) {
	fake.startProcessMutex.Lock()
	defer fake.startProcessMutex.Unlock()
	fake.StartProcessStub = nil
	if fake.startProcessReturnsOnCall == nil {
		fake.startProcessReturnsOnCall = make(map[int]struct {
			result1 *os.Process
			result2 error
		})
	}
	fake.startProcessReturnsOnCall[i] = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Stat(arg1 string) (os.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if fake.StatStub != nil {
		return fake.StatStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.statReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeOs) StatCalls(stub func(string) (os.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeOs) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) StatReturns(result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) StatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Symlink(arg1 string, arg2 string) error {
	fake.symlinkMutex.Lock()
	ret, specificReturn := fake.symlinkReturnsOnCall[len(fake.symlinkArgsForCall)]
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Symlink", []interface{}{arg1, arg2})
	fake.symlinkMutex.Unlock()
	if fake.SymlinkStub != nil {
		return fake.SymlinkStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.symlinkReturns
	return fakeReturns.result1
}

func (fake *FakeOs) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakeOs) SymlinkCalls(stub func(string, string) error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = stub
}

func (fake *FakeOs) SymlinkArgsForCall(i int) (string, string) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	argsForCall := fake.symlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) SymlinkReturns(result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) SymlinkReturnsOnCall(i int, result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	if fake.symlinkReturnsOnCall == nil {
		fake.symlinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.symlinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) TempDir() string {
	fake.tempDirMutex.Lock()
	ret, specificReturn := fake.tempDirReturnsOnCall[len(fake.tempDirArgsForCall)]
	fake.tempDirArgsForCall = append(fake.tempDirArgsForCall, struct {
	}{})
	fake.recordInvocation("TempDir", []interface{}{})
	fake.tempDirMutex.Unlock()
	if fake.TempDirStub != nil {
		return fake.TempDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tempDirReturns
	return fakeReturns.result1
}

func (fake *FakeOs) TempDirCallCount() int {
	fake.tempDirMutex.RLock()
	defer fake.tempDirMutex.RUnlock()
	return len(fake.tempDirArgsForCall)
}

func (fake *FakeOs) TempDirCalls(stub func() string) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = stub
}

func (fake *FakeOs) TempDirReturns(result1 string) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = nil
	fake.tempDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) TempDirReturnsOnCall(i int, result1 string) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = nil
	if fake.tempDirReturnsOnCall == nil {
		fake.tempDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tempDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) Truncate(arg1 string, arg2 int64) error {
	fake.truncateMutex.Lock()
	ret, specificReturn := fake.truncateReturnsOnCall[len(fake.truncateArgsForCall)]
	fake.truncateArgsForCall = append(fake.truncateArgsForCall, struct {
		arg1 string
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("Truncate", []interface{}{arg1, arg2})
	fake.truncateMutex.Unlock()
	if fake.TruncateStub != nil {
		return fake.TruncateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.truncateReturns
	return fakeReturns.result1
}

func (fake *FakeOs) TruncateCallCount() int {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return len(fake.truncateArgsForCall)
}

func (fake *FakeOs) TruncateCalls(stub func(string, int64) error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = stub
}

func (fake *FakeOs) TruncateArgsForCall(i int) (string, int64) {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	argsForCall := fake.truncateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) TruncateReturns(result1 error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = nil
	fake.truncateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) TruncateReturnsOnCall(i int, result1 error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = nil
	if fake.truncateReturnsOnCall == nil {
		fake.truncateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.truncateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Unsetenv(arg1 string) error {
	fake.unsetenvMutex.Lock()
	ret, specificReturn := fake.unsetenvReturnsOnCall[len(fake.unsetenvArgsForCall)]
	fake.unsetenvArgsForCall = append(fake.unsetenvArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Unsetenv", []interface{}{arg1})
	fake.unsetenvMutex.Unlock()
	if fake.UnsetenvStub != nil {
		return fake.UnsetenvStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unsetenvReturns
	return fakeReturns.result1
}

func (fake *FakeOs) UnsetenvCallCount() int {
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	return len(fake.unsetenvArgsForCall)
}

func (fake *FakeOs) UnsetenvCalls(stub func(string) error) {
	fake.unsetenvMutex.Lock()
	defer fake.unsetenvMutex.Unlock()
	fake.UnsetenvStub = stub
}

func (fake *FakeOs) UnsetenvArgsForCall(i int) string {
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	argsForCall := fake.unsetenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) UnsetenvReturns(result1 error) {
	fake.unsetenvMutex.Lock()
	defer fake.unsetenvMutex.Unlock()
	fake.UnsetenvStub = nil
	fake.unsetenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) UnsetenvReturnsOnCall(i int, result1 error) {
	fake.unsetenvMutex.Lock()
	defer fake.unsetenvMutex.Unlock()
	fake.UnsetenvStub = nil
	if fake.unsetenvReturnsOnCall == nil {
		fake.unsetenvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetenvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	fake.getegidMutex.RLock()
	defer fake.getegidMutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.geteuidMutex.RLock()
	defer fake.geteuidMutex.RUnlock()
	fake.getgidMutex.RLock()
	defer fake.getgidMutex.RUnlock()
	fake.getgroupsMutex.RLock()
	defer fake.getgroupsMutex.RUnlock()
	fake.getpagesizeMutex.RLock()
	defer fake.getpagesizeMutex.RUnlock()
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	fake.getppidMutex.RLock()
	defer fake.getppidMutex.RUnlock()
	fake.getuidMutex.RLock()
	defer fake.getuidMutex.RUnlock()
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	fake.tempDirMutex.RLock()
	defer fake.tempDirMutex.RUnlock()
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOs) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ osshim.Os = new(FakeOs)
